#pragma kernel Update
#pragma kernel Init
#pragma kernel Emit
#define THREAD_COUNT 256
#define PI 3.14159265351
#include "common.hlsli"

StructuredBuffer<Particle> inputs;
RWStructuredBuffer<Particle> outputs;

float maxCount;
float3 transportPosition;
float3 transportForward;
float2 time; //x = delta time, y = elapsed time
float3 seeds;
float2 lifeRange; //x = min, y = max
float rand(float3 co)
{
    return frac(sin(dot(co.xyz, float3(12.9898, 78.233, 45.5432))) * 43758.5453);
}

float3 randomPointOnSphere(float u, float v, float radius)
{
    float theta = 2 * PI * u;
    float phi = acos(2 * v - 1);
    float x = radius * sin(phi) * cos(theta);
    float y = radius * sin(phi) * sin(theta);
    float z = radius * cos(phi);
    return float3(x, y, z);
}


[numthreads(THREAD_COUNT, 1, 1)]
void Init(uint3 id : SV_DispatchThreadID)
{
    outputs[id.x].color = float4(1.0f, 1.0f, 1.0f, 1.0f);
    outputs[id.x].alive = false;
    outputs[id.x].size = 1.0f;
    outputs[id.x].data.x = 0.0f;
    outputs[id.x].data.y = lifeRange.x + (lifeRange.y - lifeRange.x) * rand(seeds.zxy / (id + 1));
    outputs[id.x].data.z = 0.0f;
}

[numthreads(1, 1, 1)]
void Emit(uint3 svid : SV_DispatchThreadID)
{
    uint id = outputs.IncrementCounter();
    if (id >= maxCount)
    {
        return;
    }
    Particle p;
    p.alive = true;
    p.position = transportPosition;
    float radius = 1.0f;
    p.forward = transportForward*2 + randomPointOnSphere(rand(seeds.xyz / (id + 1)), rand(seeds.yzx / (id + 1)), radius * rand(seeds.zyx / (id + 1)));
    p.data.x = 0.0f;
    p.data.y = lifeRange.x + (lifeRange.y - lifeRange.x) * rand(seeds.zxy / (id + 1));
    p.data.z = 0.0f;
    p.size = 1.0f;
    p.color = float4(1.0f, 1.0f, 1.0f, 1.0f);
    outputs[id] = p;
}

[numthreads(THREAD_COUNT, 1, 1)]
void Update(uint3 id : SV_DispatchThreadID)
{
    Particle p = inputs[id.x];
    if (p.data.x + time.x >= p.data.y)
    {
        return;
    }
    p.data.x += time.x;
    p.forward += float3(0,-1,0) * time.x;
    p.position += p.forward  * time.x;
    outputs[outputs.IncrementCounter()] = p;
}

