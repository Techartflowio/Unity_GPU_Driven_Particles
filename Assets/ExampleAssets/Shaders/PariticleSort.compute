// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ParticleSort
#include "common.hlsli"

StructuredBuffer<Particle> inputs;
RWByteAddressBuffer drawArgsBuffer;
RWStructuredBuffer<uint> indexBuffer;
matrix gViewProj;
#define SIZE 2048
#define HALFSIZE SIZE/2
groupshared uint SortKeys[2048];

void FillSortKey(uint GroupStart, uint Offset, uint particleNum)
{
    if (GroupStart + Offset >= particleNum)
    {
        SortKeys[Offset] = 0;        // Z = 0 will sort to the end of the list (back to front)
        return;
    }
    uint VertexIdx = GroupStart + Offset;
    Particle particle = inputs[VertexIdx];
    float4 HPos = mul(gViewProj, float4(particle.position, 1));
    float Depth = HPos.z / HPos.w;
    SortKeys[Offset] = f32tof16(Depth)  << 16 | VertexIdx;;

}
[numthreads(HALFSIZE, 1, 1)]
void ParticleSort(uint3 DTid : SV_DispatchThreadID, uint3 Gid : SV_GroupID, uint GI : SV_GroupIndex)
{
    uint particleNum = drawArgsBuffer.Load(4);
    uint GroupStart =0;
    if (GroupStart > particleNum)
    {
        SortKeys[GroupStart + GI] = 0;
        SortKeys[GroupStart + GI + HALFSIZE] = 0;
        return;
    }
    FillSortKey(GroupStart, GI, particleNum);
    FillSortKey(GroupStart, GI + HALFSIZE, particleNum);
    GroupMemoryBarrierWithGroupSync();
    [unroll]
    for (uint k = 2; k <= SIZE; k *= 2)
    {
        [unroll]
        for (uint j = k / 2; j > 0; j /= 2)
        {
            uint Index1 = InsertZeroBit(GI, j);
            uint Index2 = Index1 ^ (k == j * 2 ? k - 1 : j);

            uint A = SortKeys[Index1];
            uint B = SortKeys[Index2];

            if (A > B)
            {
                SortKeys[Index1] = B;
                SortKeys[Index2] = A;
            }

            GroupMemoryBarrierWithGroupSync();
        }
    }
    indexBuffer[ GI] = SortKeys[GI] & 0x00ffff;
    indexBuffer[ GI + HALFSIZE] = SortKeys[GI + HALFSIZE] & 0x00ffff;
   // indexBuffer[GI] = GI;
}
